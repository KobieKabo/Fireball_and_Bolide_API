# **Fireball and Bolide Tracker**

## **Project Objective**
Sift through an abundance of positional and velocity data on fireball and bolide reportings documented by NASA. Build a Flask application for querying and returning information from the NASA data set.The included Dockerfile containerizes fireball_api.py to make it portable. ADD SOMETHING ABOUT KUBERNETES

**Data Collected From:**
https://data.nasa.gov/api/views/mc52-syum/rows.xml?accessType=DOWNLOAD

**Fireball and Bolide Data Description**

The data collected from the above link is generated by U.S. Government sensors and ground-based observers. Note that this data is is not meant to be a complete list of all fireball events. Only the brightest fireballs are noted. 

What is a fireball or bolide? A fireball is an unusually bright meteor that reaches a visual magnitude of -3 or brighter when seen at the observer's zenith. Objects causing fireball events can exceed one meter in size. Fireballs that explode in the atmosphere are technically referred to as bolides although the terms fireballs and bolides are often used interchangeably. 


	Distance - [km]
	Velocity - [km/s]
	Radiated Energy - [J]
	Impact Energy - [kT]
	*Data Description adapted from https://catalog.data.gov/dataset/fireball-and-bolide-reports* 

### **fireball_api.py Description:**

The fireball_api.py script initializes a Flask instance, loads data from the NASA API linked above, and stores the data in Redis. The flask application tracks the altitude, location and velocity of the bolides which given in latitudes/longitudes and Cartesian vectors for both position.This data along with a time stamp, and calculated radiated and impact energy describe the complete state of the documented fireballs and bolides.

#### **Dockerfile Description & Instructions**

How to pull and use the Dockerfule from Docker Hub:

	docker pull khanks0217/fireball_api:1.1

	docker pull khanks0217/fireball_api:1.wrk

How to build a new image from Dockerfile:

	docker build -f Dockerfile.api -t username/fireball_api:1.1

	docker build -f Dockerfile.wrk -t username/fireball_api:1.wrk

#### **Instructions - How to use genes_api on Kubernetes**

Create a persistent volume claim (pvc)

	kubectl apply -f app-prod-db-pvc.yml

Deploy redis on the kubernetes cluster

	kubectl apply -f app-prod-db-deployment.yml


Deploy redis service on kubernetes cluster

	kubectl apply -f app-prod-db-service.yml

Add the redis IP address to the app-prod-api-deployment.yml

	kubectl get services

	Copy app-test-service IP address to the REDIS_IP value in the api deployment file.

Create a flask deployment:

	kubectl apply -f app-prod-api-deployment.yml

Create a flask service:

	kubectl apply -f app-prod-api-service.yml

Create a worker deployment:

	kubectl apply -f app-prod-wrk-deployment.yml

Create a NodePort:

	kubectl apply -f app-prod-api-nodeport.yml

Copy the nodeport port to app-prod-api-ingress.yml

	kubectl get services

	NAME                         TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)          AGE
	flasktest-service-nodeport   NodePort    10.233.15.48   <none>        5000:31587/TCP   45s

	Edit app-prod-api-ingress.yml 
	host: "username.coe332.tacc.cloud" <-- This should be your username
	...
	port:
	  number: 31587   <--This should be the same as the port from NodePort 5000:/XXXXX

Create the Ingress object:

	kubectl apply -f app-prod-api-ingress.yml

	kubectl get ingress

	NAME                CLASS    HOSTS                       ADDRESS   PORTS   AGE
	flasktest-ingress   <none>   username.coe332.tacc.cloud             80      102s

We can test by running the following curl command from anywhere, including our laptops.

	curl -X POST username.coe332.tacc.cloud/data

##### **Fireball API Front End:**

The API front end is expose on port 5000 inside the container. Try the following routes:

| Route         | Method        | Return |
| ------------- |:-------------:| ------------- |
| `/data`     | GET | Return all data in Redis database | 
| 	      | DELETE |  Delete data from Redis database | 
| 	      | POST | Post data into Redis database | 
| `/timestamp`    | GET |  Returns all available timestamps for each fireball recorded |
| `/timestamp/<string: pr_date>`  | GET |  Return all data for a specific timestamp |
| `/timestamp/<string: pr_date>/speed`  | GET |  Returns the speed of the fireball for a specific timestamp |
| `/timestamp/<string: pr_date>/energy`  | GET |  Returns the energy for a specific timestamp |
| `/timestamp/<string: pr_date>/location`  | GET |  Return geographical position for a specific timestamp |
| `/help`  | GET |  Returns text that describes each route & what they do |
|`/image`    | GET | Returns plot file from Redis_image database|
| 	     | DELETE |  Deletes plot from Redis_image database | 
| 	     | POST | Posts plot into Redis_image database | 


	$ curl -X POST localhost:5000/data	Load the entire data set into Redis.
	
	$ curl -X GET localhost:5000/data 	Returns a list of all data from Redis. 

	$ curl -X DELETE localhost:5000/data	Delete all of the data from Redis.

	$ curl localhost:5000/timestamp		Return all timestamps from Redis.

	$ curl localhost:5000/timestamp/<string: pr_date> 	Return all data for a specific timestamp.

	$ curl localhost:5000/timestamp/<string: pr_date>/speed 	Return velocity data for a specific timestamp.

	$ curl localhost:5000/timestamp/<string: pr_date>/energy 	Return energy data for a specific timestamp.

	$ curl localhost:5000/timestamp/<string: pr_date>/location 	Return positional data for a specific timestamp.

	$ curl localhost:5000/help	Returns help text (as a string) that briefly describes each route.

###### **Running iss_tracker.py**

To get graph from pod : kubectl cp app-test-flask-55db755fcb-58x6h:graph.jpg graphdownload.jpg

	
**Expected Output, Sample**
